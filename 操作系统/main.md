# OS

## 进程与线程

### 纤程
线程由操作系统对**线程工作内容无感知地**进行调度，用户级线程，即**纤程**（fiber），可以在更轻量级的创建和切换消耗下对工作在用户态进行调度。

#### 不同平台对纤程的支持
- **POSIX**（可移植操作系统接口，Portable Operating System Interface for uniX）中的**ucontext**对钎程进行了支持，其提供了如下几个接口对钎程提供服务
  - **getcontext**用于保存当前用户上下文到一个context变量，参数为需要保存到的context变量
  - **makecontext**用于修改一个存在的context，指定在此上下文中执行的函数，配合getcontext使用，参数为1.context 2.在当前上下文中需要执行的函数 3.传入的函数参数
  - **setcontext**用户切换到另一个上下文，接受一个context变量
- **Windows**也提供了与ucontext类似的接口，如**CreateFiber**，**SwitchToFiber**接口
- **很多程序语言**，如c++，ruby，Go，Lua也提供了对纤程的支持，一般将程序语言提供的纤程成为**协程**

#### 纤程的上下文内容
1. 寄存器值：PC、通用寄存器
2. 纤程独立的用户维护的调用栈

#### 线程上下文内容
1. 寄存器值：PC、通用寄存器、栈指针寄存器、特殊寄存器（如页表地址寄存器）
2. 线程独立的用户栈和内核栈
3. 线程特定数据：**线程本地存储**：维护与线程数量相同的同名变量，在线程内为全局变量
   
#### 纤程与线程上下文内容的区别
1. 最大区别是线程需要保存线程用户栈和内核栈，而纤程仅需要保存用户调用栈
2. 线程拥有自己的本地存储

## 文件系统


## 设备管理

设备通过**总线**与CPU相连，常见的设备总线有AMBA、PCIe。AMBA定义了ARM架构片上系统的通信标准。

CPU通常以读写设备寄存器的方式与设备进行通信。访问设备寄存器通常两种方式：
- 通过**内存映射I/O**（Memory-Mapped I/O, MMIO），将寄存器直接映射到内存空间并拥有独立空间，CPU可以通过load、store指令控制设备
- 通过**端口映射I/O** (Port-Mapped I/O, PMIO)，通过专门的端口操作指令（如X86的in/out指令）和设备交互

常见的设备寄存器分类：
- 控制寄存器：用于接收来自驱动程序的命令 **驱动在CPU和设备中间的什么位置和交互细节？？？**
- 状态寄存器：用于反馈当前设备的工作状态
- 输入/输入寄存器：用于驱动和设备的数据交互

**直接内存访问（Direct Memory Access，DMA）**是在设备和内存之间**主要**且更高效的数据传送形式。DMA机制允许设备绕过处理器直接读写系统内存的数据。使设备传输数据同时，CPU可以进行其他任务。

一些总线中，DMA的发起还需要**DMA控制器**的参与，DMA控制器与处理器与内存连接到同一系统总线，这样的机制被称为**第三方DMA**，也成为标准**标准DMA**。一个由处理器发起的DMA的具体步骤如下：
1. 处理器向DMA控制器发送DMA缓冲区的位置和长度，以及数据传输方向，随后放弃对总线的控制
2. DMA控制器获得总线控制权，根据从处理器获得的指令，将设备的数据copy至内存
3. DMA控制器完成DMA后向处理器发送中断，通知处理器DMA已经完成

**设备树（device tree）**是描述计算机硬件信息的数据结构，或理解为操作系统可读的硬件描述语言。包含了CPU名称、内存、总线、设备等硬件信息。

常见的设备识别机制有设备树和ACPI，ACPI是x86架构计算机上标准设备识别方案

### Linux常见设备分类
字符设备、块设备、网络设备，都是以文件接口的形式向用户态提供服务
#### 字符设备
例子：键盘、鼠标、串口、LED等
访问模式：顺序访问，以字符（字节）为粒度进行读写。调用驱动程序和设备直接交互。
通常使用的文件抽象：open(),read(),write(),close()

#### 块设备
例子：磁盘、闪存、U盘
访问模式：随机访问，以块粒度进行读写；在系统层增加一层缓存，避免和慢设备频繁交互
通常使用的文件抽象：标准读写接口read()、write()（标准文件抽象）；内存映射文件，以访问内存的形式访问文件内容，理解为操作系统对块设备提供了更灵活的操作方式，一定程度上减少用户态和内核态的切换

#### 网络设备（不是很懂）
例子：以太网、WiFi、蓝牙
访问模式：面向格式化报文的收发；在驱动层以上维护多种协议，支持不同策略
通常使用的文件抽象：socket(),send(),recv(),read(),write(),close()
网络设备处理的数据单位是网络包。网络设备使用独立的接口抽象--套接字（socket）。用户程序通过套接字接口与网络设备进行通信。

### 中断控制器
尽管CPU可以通过MMIO方式控制设备，但与设备交互需要轮询设备的状态寄存器查看设备是否可以进行下一步操作。**中断**是一种高效的方法，它让设备主动告知CPU一个外部事件发生了，操作系统需要实现一套处理逻辑，即**中断处理函数（IRQ handler）**。记录中断类型和处理函数入口的表叫做**中断向量表**。中断信息直接发送到CPU的方法随着设备种类和数量的增加变得不可行，ARM架构在CPU与设备之间引入了**中断控制器**(interrupt controller)来管理中断。

### 中断优先级
中断优先级是操作系统给中断配置的优先程度，高优先级的中断先于低优先级的中断发送给CPU处理。当CPU在处理低优先级中断时，来了一个高优先级中断，那么高优先级中断会**抢占**低优先级中断，这个过程叫做**中断嵌套**。


### 中断处理的两个部分
高优先级中断会抢占低优先级中断，导致低优先级中断得不到及时响应，为了及时响应中断，引入了中断处理的分为两个阶段的方法（linux是这么做的）。
#### 上半部（确认阶段）
完成必要且轻量级的工作，期间关闭中断，向系统注册新的处理任务
#### 下半部（处理阶段）
执行处理任务，此任务是具有较高优先级的内核任务

#### linux提供的实现下半部三种机制
- 软中断：基本的下半部处理方式，可以看做是用普通内核任务模拟硬中断处理函数的方法。软中断与硬中断区别：软中断处理函数必须是可重入的，允许中断嵌套，被硬中断抢占。软中断拥有独立的上下文，区别于硬中断上下文
- tasklet：软中断只能在代码编译时静态分配，而无法根据需要动态创建。因此有了tasklet。tasklet无需考虑重入问题，省去了同步必要，编程友好，有一个重大缺点是其依托中断上下文，执行期间不能sleep，设计上不可抢占，会导致难以预测的系统延迟
- 工作队列：借助内核线程上下文来执行，可以进行sleep增强

### 设备驱动
使操作系统和设备间能相互通信的特殊程序
