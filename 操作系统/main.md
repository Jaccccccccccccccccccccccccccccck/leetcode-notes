# OS

## 进程与线程

### 纤程
线程由操作系统对**线程工作内容无感知地**进行调度，用户级线程，即**纤程**（fiber），可以在更轻量级的创建和切换消耗下对工作在用户态进行调度。

#### 不同平台对纤程的支持
- **POSIX**（可移植操作系统接口，Portable Operating System Interface for uniX）中的**ucontext**对钎程进行了支持，其提供了如下几个接口对钎程提供服务
  - **getcontext**用于保存当前用户上下文到一个context变量，参数为需要保存到的context变量
  - **makecontext**用于修改一个存在的context，指定在此上下文中执行的函数，配合getcontext使用，参数为1.context 2.在当前上下文中需要执行的函数 3.传入的函数参数
  - **setcontext**用户切换到另一个上下文，接受一个context变量
- **Windows**也提供了与ucontext类似的接口，如**CreateFiber**，**SwitchToFiber**接口
- **很多程序语言**，如c++，ruby，Go，Lua也提供了对纤程的支持，一般将程序语言提供的纤程成为**协程**

#### 纤程的上下文内容
1. 寄存器值：PC、通用寄存器
2. 纤程独立的用户维护的调用栈

#### 线程上下文内容
1. 寄存器值：PC、通用寄存器、栈指针寄存器、特殊寄存器（如页表地址寄存器）
2. 线程独立的用户栈和内核栈
3. 线程特定数据：**线程本地存储**：维护与线程数量相同的同名变量，在线程内为全局变量
   
#### 纤程与线程上下文内容的区别
1. 最大区别是线程需要保存线程用户栈和内核栈，而纤程仅需要保存用户调用栈
2. 线程拥有自己的本地存储

## 文件系统


## 设备管理

设备通过**总线**与CPU相连，常见的设备总线有AMBA、PCIe。AMBA定义了ARM架构片上系统的通信标准。

CPU通常以读写设备寄存器的方式与设备进行通信。访问设备寄存器通常两种方式：
- 通过**内存映射I/O**（Memory-Mapped I/O, MMIO），将寄存器直接映射到内存空间并拥有独立空间，CPU可以通过load、store指令控制设备
- 通过**端口映射I/O** (Port-Mapped I/O, PMIO)，通过专门的端口操作指令（如X86的in/out指令）和设备交互

常见的设备寄存器分类：
- 控制寄存器：用于接收来自驱动程序的命令 **驱动在CPU和设备中间的什么位置和交互细节？？？**
- 状态寄存器：用于反馈当前设备的工作状态
- 输入/输入寄存器：用于驱动和设备的数据交互

**直接内存访问（Direct Memory Access，DMA）**是在设备和内存之间**主要**且更高效的数据传送形式。DMA机制允许设备绕过处理器直接读写系统内存的数据。使设备传输数据同时，CPU可以进行其他任务。

一些总线中，DMA的发起还需要**DMA控制器**的参与，DMA控制器与处理器与内存连接到同一系统总线，这样的机制被称为**第三方DMA**，也成为标准**标准DMA**。一个由处理器发起的DMA的具体步骤如下：
1. 处理器向DMA控制器发送DMA缓冲区的位置和长度，以及数据传输方向，随后放弃对总线的控制
2. DMA控制器获得总线控制权，根据从处理器获得的指令，将设备的数据copy至内存
3. DMA控制器完成DMA后向处理器发送中断，通知处理器DMA已经完成

**设备树（device tree）**是描述计算机硬件信息的数据结构，或理解为操作系统可读的硬件描述语言。包含了CPU名称、内存、总线、设备等硬件信息。

常见的设备识别机制有设备树和ACPI，ACPI是x86架构计算机上标准设备识别方案

### 中断控制器
尽管CPU可以通过MMIO方式控制设备，但与设备交互需要轮询设备的状态寄存器查看设备是否可以进行下一步操作。**中断**是一种高效的方法，它让设备主动告知CPU一个外部事件发生了，操作系统需要实现一套处理逻辑，即**中断处理函数（IRQ handler）**。记录中断类型和处理函数入口的表叫做**中断向量表**。中断信息直接发送到CPU的方法随着设备种类和数量的增加变得不可行，ARM架构在CPU与设备之间引入了**中断控制器**(interrupt controller)来管理中断。

### 中断优先级
中断优先级是操作系统给中断配置的优先程度，高优先级的中断先于低优先级的中断发送给CPU处理。当CPU在处理低优先级中断时，来了一个高优先级中断，那么高优先级中断会**抢占**低优先级中断
