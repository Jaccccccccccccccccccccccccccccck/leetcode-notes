### 叙事方式
三五法则 -> 引入移动语义 -> 引入右值引用 -> std::move()


#### 左值和右值
左值：指向特定内存的具有名称的值，具有相对稳定的内存地址，生命周期较长
右值：不指向稳定内存地址的匿名值，生命周期较短
可以使用取地址符&来判断左值和右值，能取到内存地址的值为左值，否则为右值。

#### 左值引用
左值引用常被使用，当需要将一个对象作为参数传递给子函数的时候，常常使用左值引用，免去对创建临时对象的操作。
非常量左值引用只能引用左值，常量左值引用还可以引用右值
```
int &a = 11;  // 编译失败
const int &a = 11; // 编译成功
```
常量左值引用的例子：**复制（拷贝）构造函数**和**复制（拷贝）赋值运算符函数**
下例中的复制构造函数 X(const X&) {} 和复制赋值运算符函数的形参类型的常量性（const）删除，则语句line1和line2会编译报错，因为make_x()函数返回的是一个右值，非常量左值是无法绑定的。

```
class X {
public:
  X() {}
  X(const X&) {}
  X& operator = (const X&) { return *this; }
};

X make_x()
{
  return X();
}

int main() 
{
  X x1;
  X x2(x1);
  X x3(make_x());  // line 1
  x3 = make_x();  // line2
}
```

但常量左值引用的缺点也很明显，也就是不能修改对象内容

#### 右值引用
右值引用只能引用右值，使用&&，右值引用的引入可以增加右值的生命周期，**减少对复制构造函数的调用**

即使使用了右值引用后减少了一次的复制构造函数，但由于函数的调用还是存在很多的仅存在于临时对象的右值，导致复制构造函数
```
int i = 0;
int &j = i;    // 左值引用
int &&k = 11;  // 右值引用
```

```
接收# include <iostream>

class X {
public:
  X() { std::cout << "X ctor" << std::endl; }
  X(const X&x) { std::cout << "X copy ctor" << std::endl; }
  ~X() { std::cout << "X dtor" << std::endl; }
  void show() { std::cout << "show X" << std::endl; }
};

X make_x()
{
  X x1;
  return x1;
}

int main()
{
  X &&x2 = make_x();
  x2.show();
}
```

#### 移动语义
C++11中为了支持移动操作，引入了新的引用类型: **右值引用**

**移动构造函数** 引入来降低 **复制构造函数** 的开销。
在没有移动构造函数前对于临时对象的处理只能进行调用**复制构造函数**，而不能复用临时对象的资源
**移动构造函数**用来重用临时对象的资源，因为临时对象马上就会被销毁
- 复制构造函数 接收一个左值引用，在不修改原来的对象基础上进行复制
- 移动构造函数 接收一个右值引用，重用对象里面的资源，会破坏掉原来的临时变量
  


### 拷贝控制操作
用于指令、对象的拷贝、赋值、移动和销毁的动作
有三个构造函数：
- 拷贝构造函数
- 移动构造函数
- 析构函数
有两个运算符：
- 拷贝赋值运算符
- 移动构造运算符

#### 拷贝构造函数
构造函数的参数是自身类型的引用
```
class Foo {
public:
    Foo();  // 默认构造函数
    ~Foo(); // 析构函数
    Foo(const Foo&)； // 拷贝构造函数
    Foo& operator=(const Foo&); // 拷贝赋值操作符
    Foo(Foo&&); // 移动构造函数
    Foo& operator=(Foo&&); 移动赋值操作符
}
```

#### 三五法则
通过三个（C++11中变成了五个）**拷贝控制操作**控制类的拷贝、移动、赋值和销毁。
三法则中包括：析构函数，复制构造函数，赋值运算符
五法则中添加了：移动构造函数，移动赋值运算符
- 需要解析函数的类也需要拷贝和赋值操作
- 需要拷贝的操作也需要赋值操作，反之亦然

#### std::move()
显式地把一个左值转换成右值
经过move调用的对象叫做**移后源**对象，这样的对象可以进行赋予新值或者销毁，但不可以使用一个**移后源**的值了
